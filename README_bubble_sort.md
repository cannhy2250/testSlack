# Python 冒泡排序实现 🔄

本项目提供了多个版本的冒泡排序（Bubble Sort）实现，从基础到高级，适合不同学习阶段的开发者。

## 📚 文件说明

### 1. `simple_bubble_sort.py` - 初学者版本
- ✅ 最简单易懂的实现
- ✅ 详细的步骤演示
- ✅ 清晰的中文注释
- 🎯 **推荐给初学者使用**

### 2. `bubble_sort.py` - 完整版本
- ✅ 多种冒泡排序变体
- ✅ 性能测试和比较
- ✅ 自定义排序规则
- ✅ 详细的算法分析
- 🎯 **适合深入学习和实际应用**

## 🧠 冒泡排序原理

冒泡排序是最简单的排序算法之一，其工作原理如下：

```
1. 比较相邻的两个元素
2. 如果前面的元素比后面的大，就交换它们
3. 对每一对相邻元素重复步骤1-2
4. 重复整个过程，直到没有更多的交换需要进行
```

### 🎨 可视化演示

```
初始: [64, 34, 25, 12, 22, 11, 90]

第1轮: [34, 25, 12, 22, 11, 64, 90]  ← 64冒泡到倒数第二位
第2轮: [25, 12, 22, 11, 34, 64, 90]  ← 34冒泡到正确位置
第3轮: [12, 22, 11, 25, 34, 64, 90]  ← 25冒泡到正确位置
第4轮: [12, 11, 22, 25, 34, 64, 90]  ← 22冒泡到正确位置
第5轮: [11, 12, 22, 25, 34, 64, 90]  ← 12冒泡到正确位置

结果: [11, 12, 22, 25, 34, 64, 90]   ✅ 排序完成
```

## 🚀 快速开始

### 运行简单版本
```bash
python3 simple_bubble_sort.py
```

### 运行完整版本
```bash
python3 bubble_sort.py
```

## 💻 代码示例

### 基础用法
```python
def simple_bubble_sort(arr):
    numbers = arr.copy()
    n = len(numbers)
    
    for i in range(n):
        for j in range(0, n - i - 1):
            if numbers[j] > numbers[j + 1]:
                numbers[j], numbers[j + 1] = numbers[j + 1], numbers[j]
    
    return numbers

# 使用示例
data = [64, 34, 25, 12, 22, 11, 90]
sorted_data = simple_bubble_sort(data)
print(sorted_data)  # [11, 12, 22, 25, 34, 64, 90]
```

### 高级用法（自定义排序）
```python
# 按字符串长度排序
words = ["python", "java", "c", "javascript", "go"]
sorted_by_length = bubble_sort_generic(words, key=len)
# 结果: ['c', 'go', 'java', 'python', 'javascript']

# 按绝对值排序
numbers = [-5, 3, -1, 4, -2]
sorted_by_abs = bubble_sort_generic(numbers, key=abs)
# 结果: [-1, -2, 3, 4, -5]
```

## 📊 算法分析

| 特性 | 描述 |
|------|------|
| **时间复杂度** | O(n²) 平均和最坏情况，O(n) 最好情况 |
| **空间复杂度** | O(1) 原地排序 |
| **稳定性** | ✅ 稳定排序 |
| **适用场景** | 小数据集、教学演示 |

### ⚡ 性能特点

- **优点**：
  - 实现简单，代码易懂
  - 原地排序，不需要额外空间
  - 稳定排序，相同元素的相对位置不变
  - 可以检测数组是否已经排序

- **缺点**：
  - 时间复杂度高，不适合大数据集
  - 比较次数多，效率较低

## 🎯 学习建议

### 对于初学者
1. 先运行 `simple_bubble_sort.py` 观察排序过程
2. 理解双重循环的作用
3. 手动跟踪几个小例子
4. 尝试修改代码实现降序排序

### 对于进阶学习者
1. 研究 `bubble_sort.py` 中的优化版本
2. 理解提前终止条件的重要性
3. 比较不同版本的性能差异
4. 尝试实现其他排序算法并比较

## 🔧 扩展练习

1. **实现降序冒泡排序**
2. **添加排序过程的可视化**
3. **比较冒泡排序与其他排序算法的性能**
4. **实现双向冒泡排序（鸡尾酒排序）**

## 📈 与其他排序算法的比较

| 算法 | 时间复杂度 | 空间复杂度 | 稳定性 | 适用场景 |
|------|------------|------------|--------|----------|
| 冒泡排序 | O(n²) | O(1) | ✅ | 教学、小数据 |
| 快速排序 | O(n log n) | O(log n) | ❌ | 大数据、一般用途 |
| 归并排序 | O(n log n) | O(n) | ✅ | 大数据、稳定排序 |
| 插入排序 | O(n²) | O(1) | ✅ | 小数据、部分有序 |

## 🤝 贡献

欢迎提交问题和改进建议！如果你有更好的实现方式或发现了bug，请随时联系。

## 📝 许可证

本项目采用 MIT 许可证，可自由使用和修改。

---

**Happy Coding! 🎉**